#include "CLrc2Ass.h"


CLrc2Ass::CLrc2Ass() {
	ASS_DEFAULT = "\
[Script Info]\n\
; Script generated by Aegisub 3.2.2\n\
; http://www.aegisub.org/\n\
Title: Default Aegisub file\n\
ScriptType: v4.00+\n\
WrapStyle: 0\n\
ScaledBorderAndShadow: yes\n\
YCbCr Matrix: None\n\
\n\
[Aegisub Project Garbage]\n\
\n\
[V4+ Styles]\n\
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n\
Style: 解说字幕,微软雅黑,120,&H00B50D9C,&H00FFFFFF,&H28FFFFFF,&H50F29CF8,-1,0,0,0,100,100,0,0,1,6,6,5,100,100,37,1\n\
Style: Left,微软雅黑,100,&H00C7C7C7,&H00FFFFFF,&H28FFFFFF,&H50F29CF8,-1,0,0,0,100,100,0,0,1,5,5,1,100,100,37,1\n\
Style: Right,微软雅黑,100,&H00C0C0C0,&H00FFFFFF,&H28FFFFFF,&H50F29CF8,-1,0,0,0,100,100,0,0,1,5,5,3,100,100,37,1\n\
Style: 注音,微软雅黑,50,&H00FFBBF5,&H00FFFFFF,&H28FFFFFF,&H50F29CF8,-1,0,0,0,100,100,0,0,1,4,4,2,100,100,37,1\n\
Style: 中字,微软雅黑,60,&H00E24ACC,&H00FFFFFF,&H28FFFFFF,&H50F29CF8,-1,0,0,0,100,100,0,0,1,4,4,7,100,100,37,1\n\
\n\
[Events]\n\
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n\
";
	sLrcPath.clear();
	sAssPath.clear();
	cnt = 0;
}

void ProcPath(QString& path) {
	if (path[0] == '"') {
		path = path.mid(1, path.length() - 2);
	}
}
void CLrc2Ass::SetLrcPath(QString lrc) {
	ProcPath(lrc);
	sLrcPath = lrc;
}

void CLrc2Ass::SetAssPath(QString ass) {
	ProcPath(ass);
	sAssPath = ass;
}

void CLrc2Ass::Run() {
	OpenFile();
	CopyDefault();
	Convert();

	CloseFile();
}

bool CLrc2Ass::OpenFile() {
	fin.setFileName(sLrcPath);
	bool bi = fin.open(QIODevice::ReadOnly);
	sin.setDevice(&fin);
	sin.setCodec("utf-8");

	fout.setFileName(sAssPath);
	bool bo = fout.open(QIODevice::WriteOnly);
	sout.setDevice(&fout);
	sout.setCodec("utf-8");

	return true;
}

void CLrc2Ass::CloseFile() {
	fin.close();
	fout.close();
}

void CLrc2Ass::CopyDefault() {
	sout << ASS_DEFAULT << endl;
}


void CLrc2Ass::Convert() {
	QString currLine;
	while (!sin.atEnd()) {
		QString currLine = sin.readLine();

		ConvertLine(currLine);
	}
}


void CLrc2Ass::FinishCurLine(CTime& tBegin, CTime& tEnd) {
	tBegin.Minus2s();
	tEnd.Add1s();

	QString output("Dialogue: 0,%1,%2,%4,,0,0,0,,%5{\\kf200}%3{\\kf100}");
	//QString output("Dialogue: 0,%1,%2,default,,0,0,0,,%3");
	output = output.arg(tBegin.str()).arg(tEnd.str()).arg(sCurLine);
	if (cnt % 2) {
		output = output.arg("Right").arg("{\\pos(1800,960)}{\\2c&HA510E4&}");
	}
	else {
		output = output.arg("Left").arg("{\\pos(120,800)}{\\2c&HA510E4&}");
	}
	sout << output << endl;
	sCurLine.clear();
	cnt++;
}

void CLrc2Ass::AddCurLine(CTime& tPre, CTime& tCur, QString& words) {
	int diff = tCur.GetDiff(tPre);
	sCurLine += QString("{\\kf%2}%1").arg(words).arg(diff / 10);
}

CTime CLrc2Ass::GetTime(QString& str, int& pos) {
	CTime t;
	int p = pos;
	for (; p < str.length(); p++) {
		if (str[p] == '[') {
			//[00:19:30]
			int m, s, ms;
			m = (QString() + str[p + 1] + str[p + 2]).toInt();
			s = (QString() + str[p + 4] + str[p + 5]).toInt();
			ms = (QString() + str[p + 7] + str[p + 8]).toInt() * 10;
			t.SetTime(m, s, ms);
			break;
		}
	}
	pos = p + 10;
	return t;
}
QString CLrc2Ass::GetWords(QString& str, int& pos) {
	QString words;
	int p = pos;
	int len = 0;
	for (; p < str.length(); p++) {
		if (str[p] != '[') {
			len++;
			break;
		}
	}
	pos = p;
	words = str.mid(pos, len);
	return words;
}

void CLrc2Ass::ConvertLine(QString& currLine) {
	if (currLine.isEmpty()) {
		QString output =
			"Dialogue: 0,0:00:00.00,00:00.00,default,,0,0,0,,";
		sout << output << endl;
		return;
	}
	if (currLine[0] == '@') {
		QString output =
			"Dialogue: 0,0:00:00.00,00:00.00,default,,0,0,0,," +
			currLine.mid(1);
		sout << output << endl;
		return;
	}
	CTime tBegin, tPre, tCur, tEnd;
	int pos, n;
	QString words;

	n = currLine.length();
	pos = 0;

	tBegin = GetTime(currLine, pos);
	tPre = tBegin;
	while (pos < n) {
		words = GetWords(currLine, pos);
		tCur = GetTime(currLine, pos);
		AddCurLine(tPre, tCur, words);
		tPre = tCur;
	}
	tEnd = tCur;
	FinishCurLine(tBegin, tEnd);
}

